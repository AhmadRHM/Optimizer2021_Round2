<p align="center">
  <a href="" rel="noopener">
 <img src="http://optimizer.math.sharif.edu/wp-content/uploads/2021/02/optimizer.png" alt="Optimizer logo"></a>
</p>
<h3 align="center">عقاب‌های خسته‌بال</h3>

---

<div dir = "rtl">
<p align="center"> در این بخش هدف پیدا کردن بردار
  v
  ای بود که در قیدهای داده‌شده صدق کند که این قیدها نسبت به 
  v
  خطی بودند. همچنین می‌خواستیم 
  v
  را به‌گونه‌ای پیدا کنیم که تا جای ممکن بیشترین تعداد درایه‌ی صفر را داشته باشد.
  برای حل این مساله، ابتدا نرم 
  l0
  که همان تعداد درایه‌های ناصفر v است را با نرم l1 که جمع قدر مطلق درایه‌های v است تخمین زدیم. 
  بعد از حل تخمین بالا، جوابمان را به صورت گام به گام بهبود دادیم. ایده‌ی کلی این بهبود گام به گام این بود که به درایه‌هایی که مقدار کمتری دارند بیشتر اهمیت دهیم و سعی کنیم آن‌ها را ۰ کنیم.
  در نهایت، مساله اصلی (یعنی با نرم l0) را به شکل یک مساله MILP مدل کرده، با حل آن جواب دقیق مساله را به‌دست آوردیم.
    <br> 
</p>
 </div>

## 📝 فهرست مطالب
- [صورت‌بندی سوال](#problem_statement)
- [الگوریتم بهینه‌سازی](#idea)
- [محدودیت‌ها](#limitations)
- [ایده‌های گسترش](#future_scope)
- [روند اجرا](#getting_started)
<!--- - [نحوه استفاده](#usage) --->
- [وابستگی‌ها](#tech_stack)
- [نویسندگان](#authors)
<!--- - [قدردانی](#acknowledgments) --->

## 🧐 صورت‌بندی سوال <a name = "problem_statement"></a>
![main_problem](https://github.com/AhmadRHM/Optimizer2021_Round2/blob/main/images/main_problem.png)

## 💡 الگوریتم بهینه‌سازی <a name = "idea"></a>
<div dir = "rtl">
  همانطور که گفته‌شد، ابتدا نرم l0 را با نرم l1 تخمین زدیم. یعنی مساله زیر را حل کردیم:
  
![l1_problem](https://github.com/AhmadRHM/Optimizer2021_Round2/blob/main/images/l1_problem.png)  
  برای حل این مساله نیز، آن را به شکل زیر به یک برنامه‌ریزی خطی تبدیل کردیم:

![l1_problem_lp](https://github.com/AhmadRHM/Optimizer2021_Round2/blob/main/images/l1_problem_lp.png)  
  در مساله فوق، بردار
  v<sup>abs</sup>
  قدر مطلق مقادیر بردار v خواهد بود چرا که هدف کمینه کردن مجموع درایه‌های آن است و همچنین با توجه به شروطی که برای v و 
  v<sup>abs</sup>
  تعریف کرده‌ایم، 
  v<sup>abs</sup>
  همواره از قدرمطلق v بزرگتر است.
  به این ترتیب، برنامه‌ریزی خطی بالا همان مساله‌ی اصلی با نرم l1 به جای نرم l0 آن است.   
  بعد از حل این مساله با استفاده از solver های Julia، به صورت گام به گام نتیجه را بهبود بخشیدیم. به این منظور، در هر گام با استفاده از نتایج گام قبل (و در گام اول با استفاده از نتایج تخمین l1 مساله)، وزن wi را به شکل زیر تولید کرده:  
  ![wi_definition](https://github.com/AhmadRHM/Optimizer2021_Round2/blob/main/images/wi_definition.png)  
  که در آن تابع sgn تابعی است که برای مقادیر نامنفی مقدار ۱ و برای مقادیر منفی مقدار -۱ بر می‌گرداند. 
  با استفاده از این وزن‌ها، مساله زیر را تعریف کرده و با حل آن به نتایج بهتری دست پیدا کردیم:  
  ![iteration_method_definition](https://github.com/AhmadRHM/Optimizer2021_Round2/blob/main/images/iteration_method_definition.png)   
  دقت کنید مقدار v_i ورودی تابع sgn در آخرین قید در مساله فوق، منظور متغیر v_i نیست و منظور مقداری است که در گام قبلی برای v_i به‌دست آورده‌ایم.
  ایده‌ی کلی پشت تعریف مساله بالا و وزن‌ها به صورتی که گفته شد این است که به درایه‌هایی از v که مقدار کمتری دارند اهمیت بیشتری دهیم. با منفی کردن وزن آن درایه‌هایی از v که مقدار منفی دارند سعی در زیاد کردن مقدارشان داریم و با اضافه کردن قید آخر درواقع می‌خواهیم مقدار v ها را از ۰ رد نکنیم. یعنی برای مثال اگر درایه‌ای از v در گام قبل مثبت بود، وزن مربوط به آن درایه در این مساله مقداری مثبت خواهد داشت که باعث می‌شود مقدار آن درایه بعد از حل این مساله در صورت امکان کمتر شود، اما نمی‌خواهیم این مقدار از ۰ هم کمتر شود و می‌خواهیم کم شدن آن در ۰ متوقف شود.   
  
  در نهایت، مساله MILP زیر حل شده و جواب مساله را به ما می‌دهد:  
![equation6](https://github.com/AhmadRHM/Optimizer2021_Round2/blob/main/images/MILP_definition.png)  
  در مساله فوق، اگر bi ۰ باشد، vi هم مجبور است ۰ باشد و اگر ۱ باشد نیز قید جدیدی به مساله اضافه نکرده‌ایم. از آنجا که مقداری جز این دو مقدار نیز نمی‌تواند بگیرد و همچنین تابع هدف کمینه کردن جمع bi هاست، می‌توان نتیجه گرفت برای v داده‌شده و برای b بهینه با آن v داده‌شده، bi ۰ است اگر و تنها اگر vi ۰ باشد. به این ترتیب جمع bi که همان تابع هدفمان است، تعداد درایه‌های ناصفر v را به ما می‌دهد. 
</div>

## ⛓️ محدودیت‌ها <a name = "limitations"></a>
  <div dir = "rtl">
  محدودیت خاصی برای کد این دور از مسابقه وجود ندارد.
  </div>
  
## 🚀 ایده‌های گسترش <a name = "future_scope"></a>
<div dir = "rtl">
با توجه به این که روش فوق بهترین پاسخ ممکن را پیدا می‌کند، ایده‌ای برای گسترش بیشتر وجود ندارد.
</div>

## 🏁 روند اجرا <a name = "getting_started"></a>
<div dir = "rtl">
کافیست آن را در کنار فایل ورودی قرار داده، نام فایل ورودی را در کد در خط دوم سلول دوم به نام فایل ورودی مورد نظر تغییر داده؛ مقدار size_of_v را نیز که سایز بردار v خروجی است، در خط پنجم از سلول سوم، با توجه به ابعاد داده‌ی ورودی به‌روزرسانی کنید. در نهایت سلول‌ها را به ترتیب اجرا کنید. پس از اتمام اجرا، خروجی مورد نظر در فایل output.txt در کنار کد ذخیره خواهد شد.
</div>

### پیش‌نیازها
<div dir = "rtl">
  از آنجا که در کد از زبان جولیا استفاده شده‌است، نیاز است این زبان نصب شود. همچنین بسته‌هایی که در سلول اول کد استفاده شده‌اند نیز باید نصب شود. برای نصب جولیا و بسته‌های مورد نظر می‌توانید به وب‌سایت جولیا مراجعه کنید.
  </div>

### نصب

## ⛏️ وابستگی‌ها <a name = "tech_stack"></a>
<div dir = "rtl">
همانطور که در بخش پیشنیازها گفته شد، باید زبان Julia نصب شود.
  همچنین پکیج‌های زیر نیز باید در Julia نصب شوند:
</div>
  
  
* JuMP
* ECOS
* GLPK
* MAT
* SparseArrays
* DelimitedFiles 
* LinearAlgebra
* MathOptInterface

## ✍️ نویسندگان <a name = "authors"></a>
<div dir = "rtl">
 احمد رحیمی و دیبا هاشمی
</div>
<!---## 🎉 قدردانی <a name = "acknowledgments"></a>
تشکر از هر کسی که به نحوی در گسترش این کد به شما کمک کرده است
--->
